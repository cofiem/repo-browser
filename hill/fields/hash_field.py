from django.core import checks, validators
from django.db import models
from django.utils.translation import gettext_lazy as _

from hill.validators import HexadecimalValidator


class HashField(models.CharField):
    description = _("hash of %(exact_length)s characters generated by %(algorithm)s")

    ALGORITHM_DEFINITIONS = {
        "md5": ("MD5", 32),
        "sha1": ("SHA1", 40),
        "sha256": ("SHA256", 64),
        "sha512": ("SHA512", 128),
    }
    PREFIX_SEPARATOR = ":"

    def __init__(self, *args, algorithm: str = None, **kwargs):
        prefix, length = self._algorithm_details(algorithm)
        kwargs["max_length"] = length
        super().__init__(*args, **kwargs)
        self.exact_length = length
        self.algorithm = algorithm
        self.validators.append(validators.MinLengthValidator(length))
        self.validators.append(
            HexadecimalValidator(prefix_separator=self.PREFIX_SEPARATOR)
        )

    def check(self, **kwargs):
        return [
            *super().check(**kwargs),
            *self._check_algorithm_attribute(**kwargs),
        ]

    def _check_algorithm_attribute(self, **kwargs):
        items = self.ALGORITHM_DEFINITIONS.keys()
        keys = ", ".join(sorted(items))
        if self.algorithm is None:
            return [
                checks.Error(
                    "HashFields must define an 'algorithm' attribute.",
                    obj=self,
                    id="fields.E801",
                )
            ]
        elif self.algorithm not in items:
            return [
                checks.Error(
                    f"'algorithm' must be one of {keys}.",
                    obj=self,
                    id="fields.E802",
                )
            ]
        else:
            return []

    def get_internal_type(self):
        return "CharField"

    def from_db_value(self, value, expression, connection):
        """Called in all circumstances when the data is loaded from the database."""
        if value is None:
            return value
        return self._parse_hash(value)

    def to_python(self, value):
        if value is None:
            return value

        return self._parse_hash(value)

    def get_prep_value(self, value):
        prefix, length = self._algorithm_details(self.algorithm)
        return self.PREFIX_SEPARATOR.join([prefix, value])

    def value_to_string(self, obj):
        value = self.value_from_object(obj)
        return self.get_prep_value(value)

    def deconstruct(self):
        name, path, args, kwargs = super().deconstruct()
        if self.exact_length:
            kwargs["exact_length"] = self.exact_length
        if self.algorithm:
            kwargs["algorithm"] = self.algorithm
        return name, path, args, kwargs

    def _algorithm_details(self, algorithm: str):
        """Select the algorithm prefix and hash string length."""
        if not algorithm:
            return None, None
        items = self.ALGORITHM_DEFINITIONS
        keys = items.keys()
        if algorithm not in keys:
            return None, None
        return items[algorithm]

    def _parse_hash(self, value):
        """Return the application-visible value."""
        if not value:
            return None
        value_str = str(value)
        if self.PREFIX_SEPARATOR in value_str:
            return value_str.split(sep=self.PREFIX_SEPARATOR, maxsplit=1)[-1]
        else:
            return value_str
